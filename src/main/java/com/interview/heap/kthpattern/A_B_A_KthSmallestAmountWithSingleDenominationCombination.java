package com.interview.heap.kthpattern;

import java.util.*;
/*
https://leetcode.com/problems/kth-smallest-amount-with-single-denomination-combination/description/
Category: Hard
Related:
https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ Hard
https://leetcode.com/problems/find-the-number-of-possible-ways-for-an-event/ Hard
You are given an integer array coins representing coins of different denominations and an integer k.

You have an infinite number of coins of each denomination. However, you are not allowed to combine coins of different denominations.

Return the kth smallest amount that can be made using these coins.



Example 1:

Input: coins = [3,6,9], k = 3

Output: 9

Explanation: The given coins can make the following amounts:
Coin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.
Coin 6 produces multiples of 6: 6, 12, 18, 24, etc.
Coin 9 produces multiples of 9: 9, 18, 27, 36, etc.
All of the coins combined produce: 3, 6, 9, 12, 15, etc.

Example 2:

Input: coins = [5,2], k = 7

Output: 12

Explanation: The given coins can make the following amounts:
Coin 5 produces multiples of 5: 5, 10, 15, 20, etc.
Coin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.
All of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14, 15, etc.



Constraints:

1 <= coins.length <= 15
1 <= coins[i] <= 25
1 <= k <= 2 * 109
coins contains pairwise distinct integers.
 */
public class A_B_A_KthSmallestAmountWithSingleDenominationCombination {


    /*
    âœ… Your Approach: Explanation
You treat each coin as generating a sorted list of values:

For coin c, its list is: c, 2c, 3c, ...

So, you're essentially merging n sorted infinite lists, where each list is generated by one coin.

You use a min heap to always get the next smallest value, and a seen set to eliminate duplicates across these lists.

Steps:
Sort coins: Not strictly required, but helps maintain predictable order.

Initialize Min Heap:

For each coin c, add the first value [c, c] to the heap (value = c, base = c).

Pop from the heap, check if value has been seen:

If not, add to seen.

If seen.size() == k, return the value.

Push the next value from the same list:

Push value + base into the heap, continuing the list for that coin.

ðŸ§  Why This Works
You're simulating k-way merge across infinite sorted sequences generated by each coin. Since we're guaranteed unique combinations from different coins, the heap gives us the next minimum unseen sum efficiently.

ðŸ“Š Time & Space Complexity
âœ… Time Complexity:
Let:

n = number of coins

k = target rank

In worst-case, you might push up to O(k * n) items into the heap.

Each heap operation takes O(log n) time (heap size at most n).

So amortized time complexity is:
ðŸ”¸ O(k log n)

âœ… Space Complexity:
O(n) for the heap (one per coin in worst case).

O(k) for the seen set to store unique values.

ðŸ‘‰ Total space: O(n + k)
     */
    private static class Better {//Kmerge pattern
        public long findKthSmallest(int[] coins, int k) {
            Arrays.sort(coins);//Without sorting will also work
            PriorityQueue<long[]> minHeap = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));

            for (int coin : coins) {
                minHeap.offer(new long[]{coin, coin}); // {value, base coin}
            }

            long value = 0;
            Set<Long> seen = new HashSet<>();
            while (!minHeap.isEmpty()) {
                long[] curr = minHeap.poll();
                value = curr[0];
                long base = curr[1];
                seen.add(value);

                if (seen.size() == k) {
                    return value;
                }

                long next = value + base;
                minHeap.offer(new long[]{next, base});

            }

            return value;
        }
    }

    /*
    Approach:
We binary search on the value of the k-th smallest number.

For a number mid, count how many distinct amounts â‰¤ mid can be formed using coin * x.

Key Idea:
For a coin c, the number of values â‰¤ mid is mid / c.
Total count = sum over all coins.
Time Complexity:
Binary search range: log(1e18) â‰ˆ 60

Count function per coin: O(n)

Total: O(n * log(maxAmount))

Space Complexity:
O(1) â€” constant space.
     */
    private static class Optimal {//this code is not working please explore when time permits
        public long findKthSmallest(int[] coins, int k) {
            long low = 1, high = (long) 1e18;

            while (low < high) {
                long mid = (low + high) / 2;
                long count = 0;

                for (int coin : coins) {
                    count += mid / coin;
                    if (count >= k) break;
                }

                if (count >= k) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }

            return low;
        }
    }


}
